{"version":3,"file":"dataset.min.js","sources":["../node_modules/.pnpm/@saehrimnir+druidjs@0.3.16/node_modules/@saehrimnir/druidjs/dist/druid.esm.js","../src/utils.js","../src/waves.js","../src/swissroll.js","../src/sshape.js","../src/rays.js","../src/moons.js","../src/blobs.js","../src/penguins.js","../src/openml.js","../src/fmnist.js","../src/kmnist.js","../src/mnist.js"],"sourcesContent":["// https://renecutura.eu v0.3.16 Copyright 2021 Rene Cutura\n/**\n * Computes the euclidean distance (l_2) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias euclidean\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the euclidean distance between {@link a} and {@link b}.  \n */\nfunction euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}\n/**\n * Numerical stable summation with the Kahan summation algorithm.\n * @memberof module:numerical\n * @alias kahan_sum\n * @param {Array} summands - Array of values to sum up.\n * @returns {number} The sum.\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}\n */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}\n/**\n * Numerical stable summation with the Neumair summation algorithm.\n * @memberof module:numerical\n * @alias neumair_sum\n * @param {Array} summands - Array of values to sum up.\n * @returns {number} The sum.\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}\n */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}\n/**\n * Computes the squared euclidean distance (l_2^2) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias euclidean_squared\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.  \n */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}\n/**\n * Computes the cosine distance (not similarity) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias cosine\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @example\n * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4\n * @returns {Number} The cosine distance between {@link a} and {@link b}.\n */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}\n/**\n * Computes the manhattan distance (l_1) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias manhattan\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the manhattan distance between {@link a} and {@link b}.  \n */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}\n/**\n * Computes the chebyshev distance (l_∞) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias chebyshev\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the chebyshev distance between {@link a} and {@link b}.  \n */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}\n/**\n * Computes the canberra distance between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias canberra\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} The canberra distance between {@link a} and {@link b}.\n * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}\n */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}\n/**\n * Computes the jaccard distance between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias jaccard\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the jaccard distance between {@link a} and {@link b}.  \n */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}\n/**\n * Computes the hamming distance between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias hamming\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the hamming distance between {@link a} and {@link b}.  \n */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}\n/**\n * Computes the Sokal-Michener distance between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias sokal_michener\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  \n */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}\n/**\n * Computes the yule distance between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias yule\n * @param {Array<Number>} a \n * @param {Array<Number>} b \n * @returns {Number} the yule distance between {@link a} and {@link b}.  \n */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}\n/**\n * \n * @param {*} A \n * @param {*} k \n * @param {*} distance_matrix \n * @param {*} metric \n */function k_nearest_neighbors(t,e,r=null,s=euclidean){const i=t.shape[0];let n=r??distance_matrix(t,s),o=new Array(i);\n/* for (let i = 0; i < n; ++i) {\n        D[i] = Array.from(D[i]).map((_,j) => {\n                return {\n                    i: i, j: j, distance: D[i][j]\n                }\n            })\n            .sort((a, b) => a.distance - b.distance)\n            .slice(1, k + 1)\n    } */for(let t=0;t<i;++t)o[t]=Array.from(n.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return o}\n/**\n * @class\n * @alias Matrix\n * @requires module:numerical/neumair_sum\n */class Matrix{\n/**\n     * creates a new Matrix. Entries are stored in a Float64Array. \n     * @constructor\n     * @memberof module:matrix\n     * @alias Matrix\n     * @param {number} rows - The amount of rows of the matrix.\n     * @param {number} cols - The amount of columns of the matrix.\n     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or \"zeros\", \"identity\" or \"I\", or \"center\".\n     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.\n     *  - **string**: allowed are\n     *      - \"zero\", creates a zero matrix.\n     *      - \"identity\" or \"I\", creates an identity matrix.\n     *      - \"center\", creates an center matrix.\n     *  - **number**: create a matrix filled with the given value.\n     * @example\n     * \n     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.\n     * let B = new Matrix(3, 3, \"I\"); // creates a 3 times 3 identity matrix.\n     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.\n     */\nconstructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if(\"function\"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if(\"string\"==typeof r){if(\"zeros\"===r)return new Matrix(t,e,0);if(\"identity\"===r||\"I\"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if(\"center\"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if(\"number\"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}\n/**\n     * Creates a Matrix out of {@link A}.\n     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.\n     * @param {\"row\"|\"col\"|\"diag\"} [type = \"row\"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector. \n     * @returns {Matrix}\n     * \n     * @example\n     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.\n     * let S = Matrix.from([1, 2, 3], \"diag\"); // creates a three by three matrix with 1, 2, 3 on its diagonal.\n     */static from(t,e=\"row\"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if(\"number\"==typeof t)return new Matrix(1,1,t);throw\"error\"}{let r=t.length;if(0===r)throw\"Array is empty\";\n// 1d\nif(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if(\"row\"===e)return new Matrix(1,r,((e,r)=>t[r]));\n// 2d\nif(\"col\"===e)return new Matrix(r,1,(e=>t[e]));if(\"diag\"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw\"1d array has NaN entries\"}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw\"various array lengths\";return new Matrix(r,e,((e,r)=>t[e][r]))}}}\n/**\n     * Returns the {@link row}th row from the Matrix.\n     * @param {int} row \n     * @returns {Array}\n     */row(t){\n/* let result_row = new Array(this._cols);\n        for (let col = 0; col < this._cols; ++col) {\n            result_row[col] = this._data[row * this._cols + col];\n        }\n        return result_row; */\nconst e=this._data,r=this._cols;return e.subarray(t*r,(t+1)*r)}\n/**\n     * Returns an generator yielding each row of the Matrix.\n     */*iterate_rows(){const t=this._cols,e=this._rows,r=this._data;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}\n/**\n     * Makes a {@link Matrix} object an iterable object.\n     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}\n/**\n     * Sets the entries of {@link row}th row from the Matrix to the entries from {@link values}.\n     * @param {int} row \n     * @param {Array} values \n     * @returns {Matrix}\n     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e._data[t]}return this}\n/**\n     * Returns the {@link col}th column from the Matrix.\n     * @param {int} col \n     * @returns {Array}\n     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this._data[r*this._cols+t];return e}\n/**\n     * Returns the {@link col}th entry from the {@link row}th row of the Matrix.\n     * @param {int} row \n     * @param {int} col \n     * @returns {float64}\n     */entry(t,e){return this._data[t*this._cols+e]}\n/**\n     * Sets the {@link col}th entry from the {@link row}th row of the Matrix to the given {@link value}.\n     * @param {int} row \n     * @param {int} col \n     * @param {float64} value\n     * @returns {Matrix}\n     */set_entry(t,e,r){return this._data[t*this._cols+e]=r,this}\n/**\n     * Returns a new transposed Matrix.\n     * @returns {Matrix}\n     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}\n/**\n     * Returns a new transposed Matrix. Short-form of {@function transpose}.\n     * @returns {Matrix}\n     */get T(){return this.transpose()}\n/**\n     * Returns the inverse of the Matrix.\n     * @returns {Matrix}\n     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{\n// swap rows\nfor(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}\n/**\n     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.\n     * @param {(Matrix|Array|Float64Array)} B the right side\n     * @returns {(Matrix|Array)}\n     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw`A.dot(B): A is a ${e.shape.join(\" x \")}-Matrix, B is a ${t.shape.join(\" x \")}-Matrix: \\n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \\n                Must be equal!`;let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`;let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw\"B must be Matrix or Array\"}\n/**\n     * Computes the outer product from {@link this} and {@link B}.\n     * @param {Matrix} B \n     * @returns {Matrix}\n     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}\n/**\n     * Appends matrix {@link B} to the matrix.\n     * @param {Matrix} B - matrix to append.\n     * @param {\"horizontal\"|\"vertical\"|\"diag\"} [type = \"horizontal\"] - type of concatenation.\n     * @returns {Matrix}\n     * @example\n     * \n     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.\n     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.\n     * \n     * A.concat(B, \"horizontal\"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]\n     * A.concat(B, \"vertical\"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]\n     * A.concat(B, \"diag\"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]\n     */concat(t,e=\"horizontal\"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if(\"horizontal\"==e){if(s!=n)throw`A.concat(B, \"horizontal\"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`;const e=new Matrix(s,i+o,\"zeros\");return e.set_block(0,0,r),e.set_block(0,i,t),e}if(\"vertical\"==e){if(i!=o)throw`A.concat(B, \"vertical\"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`;const e=new Matrix(s+n,i,\"zeros\");return e.set_block(0,0,r),e.set_block(s,0,t),e}if(\"diag\"==e){const e=new Matrix(s+n,i+o,\"zeros\");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw`type must be \"horizontal\" or \"vertical\", but type is ${e}!`}\n/**\n     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.\n     * @param {int} offset_row \n     * @param {int} offset_col \n     * @param {Matrix} B \n     * @returns {Matrix}\n     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}\n/**\n     * Extracts the entries from the {@link start_row}th row to the {@link end_row}th row, the {@link start_col}th column to the {@link end_col}th column of the matrix.\n     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.\n     * @param {Number} start_row \n     * @param {Number} start_col\n     * @param {Number} [end_row = null]\n     * @param {Number} [end_col = null] \n     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.\n     * @example\n     * \n     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.\n     * \n     * A.get_block(1, 1).to2dArray; // [[5, 6], [8, 9]]\n     * A.get_block(0, 0, 1, 1).to2dArray; // [[1]]\n     * A.get_block(1, 1, 2, 2).to2dArray; // [[5]]\n     * A.get_block(0, 0, 2, 2).to2dArray; // [[1, 2], [4, 5]]\n     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;\n/*if (!end_row)) {\n            end_row = rows;\n        }\n            end_col = cols;\n        }*/if(s=s??n,(r=r??i)<=t||s<=e)throw`\\n                end_row must be greater than start_row, and \\n                end_col must be greater than start_col, but\\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`;const o=new Matrix(r-t,s-e,\"zeros\");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;\n//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));\n}\n/**\n     * Returns a new array gathering entries defined by the indices given by argument.\n     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix \n     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix \n     * @returns {Matrix}\n     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}\n/**\n     * Applies a function to each entry of the matrix.\n     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.\n     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.\n     */_apply_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this._data;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw\"cols !== value_cols\";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw\"rows !== value_rows\";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw\"error\";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw\"error\";for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}\n/**\n     * Clones the Matrix.\n     * @returns {Matrix}\n     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this._data.slice(0),t}mult(t){return this.clone()._apply(t,((t,e)=>t*e))}divide(t){return this.clone()._apply(t,((t,e)=>t/e))}add(t){return this.clone()._apply(t,((t,e)=>t+e))}sub(t){return this.clone()._apply(t,((t,e)=>t-e))}\n/**\n     * Returns the number of rows and columns of the Matrix.\n     * @returns {Array} An Array in the form [rows, columns].\n     */get shape(){return[this._rows,this._cols]}\n/**\n     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.\n     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.\n     * @returns {Matrix}\n     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}\n/**\n     * Returns the Matrix as a two-dimensional Array.\n     * @returns {Array}\n     */get to2dArray(){\n/* const rows = this._rows;\n        const cols = this._cols;\n        let result = new Array(rows)\n        for (let row = 0; row < rows; ++row) {\n            let result_col = new Array(cols)\n            for (let col = 0; col < cols; ++col) {\n                result_col[col] = this.entry(row, col);\n            }\n            result[row] = result_col;\n        }\n        return result; */\nreturn[...this.iterate_rows()]}\n/**\n     * Returns the diagonal of the Matrix.\n     * @returns {Array}\n     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}\n/**\n     * Returns the mean of all entries of the Matrix.\n     * @returns {float64}\n     */get mean(){return this.sum/(this._rows*this._cols)}\n/**\n     * Returns the sum oof all entries of the Matrix.\n     * @returns {number}\n     */get sum(){return neumair_sum(this._data)}\n/**\n     * Returns the mean of each row of the matrix.\n     * @returns {Array}\n     */get meanRows(){const t=this._data,e=this._rows,r=this._cols;let s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}\n/** Returns the mean of each column of the matrix.\n     * @returns {Array}\n     */get meanCols(){const t=this._data,e=this._rows,r=this._cols;let s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}static solve_CG(t,e,r,s=.001){const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,\"horizontal\")}return o}\n/**\n     * Solves the equation {@link A}x = {@link b}. Returns the result x.\n     * @param {Matrix} A - Matrix or LU Decomposition\n     * @param {Matrix} b - Matrix\n     * @returns {Matrix}\n     */static solve(t,e){let{L:r,U:s}=\"L\"in t&&\"U\"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();\n// forward\nfor(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}\n// backward\nfor(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}\n/**\n     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.\n     * @param {Matrix} A \n     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.\n     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,\"zeros\"),s=new Matrix(e,e,\"identity\");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}\n/**\n     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}\n     * @param {Matrix} M \n     * @param {int} [k=2] \n     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}\n     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};\n//Algorithm 1a: Householder reduction to bidiagonal form:\n/* const [m, n] = A.shape;\n        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);\n        console.log(U.to2dArray)\n        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);\n        console.log(V.to2dArray)\n        let B = Matrix.bidiagonal(A.clone(), U, V);\n        console.log(U,V,B)\n        return { U: U, \"Sigma\": B, V: V }; */}}function distance_matrix(t,e=euclidean){let r=t.shape[0];\n/* let D = new Array(n);\n    for (let i = 0; i < n; ++i) {\n        D[i] = new Float64Array(n);\n    }\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            D[i][j] = D[j][i] = metric(A[i], A[j]);\n        }\n    } */const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}\n//import { neumair_sum } from \"../numerical/index\";\nfunction norm(t,e=euclidean){\n//export default function(vector, p=2, metric = euclidean) {\nlet r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw\"matrix must be 1d!\";r=t.col(0)}}else r=t;let s=r.length,i=new Array(s);return i.fill(0),e(r,i);\n/*let v;\n    if (vector instanceof Matrix) {\n        let [ rows, cols ] = v.shape;\n        if (rows === 1) {\n            v = vector.row(0);\n        } else if (cols === 1) {\n            v = vector.col(0);\n        } else {\n            throw \"matrix must be 1d\"\n        }\n    } else {\n        v = vector;\n    }\n    return Math.pow(neumair_sum(v.map(e => Math.pow(e, p))), 1 / p)*/}class Randomizer{\n// https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js\n/**\n     * Mersenne Twister\n     * @param {*} _seed \n     */\nconstructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r;this._mti==this._N+1&&(this.seed=5489);let s=this._N-this._M,i=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}choice(t,e){if(t instanceof Matrix){let[r,s]=t.shape;if(e>r)throw\"n bigger than A!\";let i=new Array(e),n=linspace(0,r-1);for(let t=0,r=n.length;t<e;++t,--r){let e=this.random_int%r;i[t]=n.splice(e,1)[0]}return i.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw\"n bigger than A!\";let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}static choice(t,e,r=19870307){let[s,i]=t.shape;if(e>s)throw\"n bigger than A!\";let n=new Randomizer(r),o=new Array(e),a=linspace(0,s-1);\n/*let index_list = new Array(rows);\n        for (let i = 0; i < rows; ++i) {\n            index_list[i] = i;\n        }*/\n//let result = new Matrix(n, cols);\nfor(let t=0,r=a.length;t<e;++t,--r){let e=n.random_int%r;o[t]=a.splice(e,1)[0]}\n//return result;\n//return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))\nreturn o.map((e=>t.row(e)))}}function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}\n/**\n * @class\n * @alias Heap\n */class Heap{\n/**\n     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.\n     * @constructor\n     * @memberof module:datastructure\n     * @alias Heap\n     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.\n     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.\n     * @param {(\"min\"|\"max\"|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\n     * @returns {Heap}\n     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}\n     */\nconstructor(t=null,e=(t=>t),r=\"min\"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator=\"min\"==r?(t,e)=>t<e:\"max\"==r?(t,e)=>t>e:r,this)}\n/**\n     * Creates a Heap from an Array\n     * @param {Array|Set} elements - Contains the elements for the Heap.\n     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.\n     * @param {(String=|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\n     * @returns {Heap}\n     */static heapify(t,e=(t=>t),r=\"min\"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}\n/**\n     * Swaps elements of container array.\n     * @private\n     * @param {Number} index_a \n     * @param {Number} index_b \n     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}\n/**\n     * @private\n     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}\n/**\n     * Pushes the element to the heap.\n     * @param {} element\n     * @returns {Heap}\n     */push(t){const e={element:t,value:this._accessor(t)};\n//const node = new Node(element, value);\nreturn this._container.push(e),this._heapify_up(),this}\n/**\n     * @private\n     * @param {Number} [start_index = 0] \n     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw\"index higher than length\";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}\n/**\n     * Removes and returns the top entry of the heap.\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}\n/**\n     * Returns the top entry of the heap without removing it.\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */get first(){return this._container.length>0?this._container[0]:null}\n/**\n     * Yields the raw data\n     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}\n/**\n     * Returns the heap as ordered array.\n     * @returns {Array} Array consisting the elements ordered by {@link comparator}.\n     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}\n/**\n     * Returns elements of container array.\n     * @returns {Array} Array consisting the elements.\n     */data(){return this._container.map((t=>t.element))}\n/**\n     * Returns the container array.\n     * @returns {Array} The container array.\n     */raw_data(){return this._container}\n/**\n     * The size of the heap.\n     * @returns {Number}\n     */get length(){return this._container.length}\n/**\n     * Returns false if the the heap has entries, true if the heap has no entries.\n     * @returns {Boolean}\n     */get empty(){return 0===this.length}}\n/**\n * @class\n * @alias DisjointSet\n * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}\n */class DisjointSet{\n/**\n     * @constructor\n     * @alias DisjointSet\n     * @memberof module:datastructure\n     * @param {Array=} elements \n     * @returns {DisjointSet}\n     */\nconstructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,\n// keep track of children?\ns.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}\n/**\n * @class\n * @alias BallTree\n */class BallTree{\n/**\n     * Generates a BallTree with given {@link elements}.\n     * @constructor\n     * @memberof module:knn\n     * @alias BallTree\n     * @param {Array=} elements - Elements which should be added to the BallTree\n     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance\n     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}\n     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}\n     * @returns {BallTree}\n     */\nconstructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}\n/**\n     * \n     * @param {Array<*>} elements - new elements.\n     * @returns {BallTree}\n     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}\n/**\n     * @private\n     * @param {Array<*>} elements \n     * @returns {Node} root of balltree.\n     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}\n/**\n     * @private\n     * @param {Node} B \n     * @returns {Number}\n     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}\n/**\n     * \n     * @param {*} t - query element.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.\n     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),\"max\"),this._root)}\n/**\n     * @private\n     * @param {*} t - query element.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.\n     * @param {Node|Leaf} B \n     */_search(t,e,r,s){\n// B is Node\nif(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;\n// B is leaf\nif(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}\n/**\n * @class\n * @alias KNN\n */class KNN{\n/**\n     * Generates a KNN list with given {@link elements}.\n     * @constructor\n     * @memberof module:knn\n     * @alias KNN\n     * @param {Array=} elements - Elements which should be added to the KNN list\n     * @param {Function|\"precomputed\"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance\n     * @returns {KNN}\n     */\nconstructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D=\"precomputed\"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),\"min\");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}\n/**\n     * \n     * @param {Array|Number} t - query element or index.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.\n     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if(\"precomputed\"==this._metric)throw\"Search by query element is only possible when not using a precomputed distance matrix!\";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}\n/**\n * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.\n * @memberof module:linear_algebra\n * @alias qr\n * @param {Matrix} A\n * @returns {{R: Matrix, Q: Matrix}}\n * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}\n */function qr(t){const[e,r]=t.shape,s=new Matrix(e,r,\"identity\"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}\n/**\n * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.\n * @param {Matrix} A - The Matrix\n * @param {Number} k - The number of eigenvectors and eigenvalues to compute.\n * @param {Number} [max_iterations=100] - The number of maxiumum iterations the algorithm should run.\n * @param {Number|Randomizer} [seed=1212] - The seed value or a randomizer used in the algorithm.\n * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.\n */function simultaneous_poweriteration$1(t,e=2,r=100,s=1212){const i=s instanceof Randomizer?s:new Randomizer(s);t instanceof Matrix||(t=Matrix.from(t));const n=t.shape[0];let{Q:o,R:a}=qr(new Matrix(n,e,(()=>i.random)));for(;r--;){const e=a.clone(),s=qr(t.dot(o));o=s.Q,a=s.R,neumair_sum(a.sub(e).diag)/n<1e-12&&(r=0)}return{eigenvalues:a.diag,eigenvectors:o.transpose().to2dArray}}\n/**\n * @class\n * @alias DR\n */class DR{\n//static parameter_list = [];\nget parameter_list(){return this._parameter_list}set parameter_list(t){return this._parameter_list=t,this}\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias DR\n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data. \n     * @param {number} [d = 2] - the dimensionality of the projection.\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {seed} [seed=1987] - the seed value for the random number generator.\n     * @returns {DR}\n     */constructor(t,e=2,r=euclidean,s=1212){if(Array.isArray(t))this._type=\"array\",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw\"no valid type for X\";this._type=\"matrix\",this.X=t}return[this._N,this._D]=this.X.shape,this._d=e,this._metric=r,this._seed=s,this._randomizer=new Randomizer(s),this._is_initialized=!1,this}\n/**\n     * Set and get parameters\n     * @param {String} name - name of the parameter.\n     * @param {Number} [value = null] - value of the parameter to set, if null then return actual parameter value.\n     */parameter(t,e=null){if(-1===this.parameter_list.findIndex((e=>e===t)))throw t+\" is not a valid parameter!\";return e?(this[\"_\"+t]=e,this):this[\"_\"+t]}\n/**\n     * Alias for 'parameter'.\n     * @param {String} name \n     * @param {Number} value \n     */para(t,e=null){return this.parameter(t,e)}\n/**\n     * Alias for 'parameter'.\n     * @param {String} name \n     * @param {Number} value \n     */p(t,e=null){return this.parameter(t,e)}\n/**\n     * Computes the projection.\n     * @returns {Matrix} Returns the projection.\n     */transform(){return this.check_init(),this.Y}generator(){return this.transform()}check_init(){this._is_initialized||\"function\"!=typeof this.init||(this.init(),this._is_initialized=!0)}\n/**\n     * @returns {Matrix} Returns the projection.\n     */get projection(){return\"matrix\"===this._type?this.Y:this.Y.to2dArray}async transform_async(){return this.transform()}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}\n/**\n * @class\n * @alias PCA\n * @augments DR\n */class PCA extends DR{\n/**\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias PCA \n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @returns {PCA}\n     */\nconstructor(t,e=2){return super(t,e),this}\n/**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */transform(){let t=this.X,e=t.shape[1],r=new Matrix(e,e,\"center\"),s=t.dot(r),i=s.transpose().dot(s),{eigenvectors:n}=simultaneous_poweriteration$1(i,this._d);return n=Matrix.from(n).transpose(),this.Y=t.dot(n),this.projection}}\n/**\n * @class\n * @alias MDS\n */class MDS extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias MDS\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function|\"precomputed\"} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     */\nconstructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}\n/**\n     * Transforms the inputdata {@link X} to dimensionality {@link d}.\n     */transform(){const t=this.X,e=t.shape[0],r=this._metric,s=\"precomputed\"===r?t:distance_matrix(t,r),i=s.meanCols,n=s.meanRows,o=s.mean;this._d_X=s;const a=new Matrix(e,e,((t,e)=>s.entry(t,e)-i[t]-n[e]+o)),{eigenvectors:h}=simultaneous_poweriteration$1(a,this._d);return this.Y=Matrix.from(h).transpose(),this.projection}get stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}\n/**\n * @class\n * @alias ISOMAP\n */class ISOMAP extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias ISOMAP\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} neighbors - the number of neighbors {@link ISOMAP} should use to project the data.\n     * @param {Number} [d = 2] - the dimensionality of the projection. \n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points. \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     */\nconstructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=[\"k\"],this.parameter(\"k\",Math.min(e??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this}\n/**\n     * Computes the projection.\n     * @returns {Matrix} Returns the projection.\n     */transform(){this.check_init();const t=this.X,e=this._N,r=this._metric,s=new Matrix;s.shape=[e,e,(e,i)=>e<=i?r(t.row(e),t.row(i)):s.entry(i,e)];const i=[];for(let t=0;t<e;++t){const r=[];for(let i=0;i<e;++i)r.push({index:i,distance:s.entry(t,i)});const n=new Heap(r,(t=>t.distance),\"min\");i.push(n.toArray().slice(1,this._k+1))}\n/*D = dijkstra(kNearestNeighbors);*/\n// compute shortest paths\n// TODO: make extern\n/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const n=new Matrix(e,e,((t,e)=>{const r=i[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)n.set_entry(t,r,Math.min(n.entry(t,r),n.entry(t,s)+n.entry(s,r)));let o=new Float64Array(e),a=new Float64Array(e),h=0,l=new Matrix(e,e,((t,e)=>{let r=n.entry(t,e);return r=r===1/0?0:r,o[t]+=r,a[e]+=r,h+=r,r}));o=o.map((t=>t/e)),a=a.map((t=>t/e)),h/=e**2;const _=new Matrix(e,e,((t,e)=>l.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:c}=simultaneous_poweriteration$1(_,this._d);\n// compute d eigenvectors\n// return embedding\nreturn this.Y=Matrix.from(c).transpose(),this.projection}}\n/**\n * @class\n * @alias FASTMAP\n */class FASTMAP extends DR{\n/**\n     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias FASTMAP\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @returns {FASTMAP}\n     * @see {@link https://doi.org/10.1145/223784.223812}\n     */\nconstructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}\n/**\n     * Chooses two points which are the most distant in the actual projection.\n     * @private\n     * @param {function} dist \n     * @returns {Array} An array consisting of first index, second index, and distance between the two points.\n     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}\n/**\n     * Computes the projection.\n     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.\n     */transform(){const t=this.X,e=t.shape[0],r=this._d,s=this._metric,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;\n// choose pivot objects\nconst[s,n,o]=this._choose_distant_objects(dist);\n// record id of pivot objects\n//PA[0].push(a_index);\n//PA[1].push(b_index);\n/* if (d_ab === 0) {\n                // because all inter-object distances are zeros\n                for (let i = 0; i < N; ++i) {\n                    Y.set_entry(i, _col, 0);\n                }\n            } else { */if(0!==o){\n// project the objects on the line (O_a, O_b)\nfor(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}\n// consider the projections of the objects on a\n// hyperplane perpendicluar to the line (a, b);\n// the distance function D'() between two \n// projections is given by Eq.4\ndist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}\n// return embedding\nreturn this.Y=i,this.projection}}\n/**\n * @class\n * @alias LDA\n */class LDA extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LDA\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Array} labels - the label / class of each data point.\n     * @param {number} [d = 2] - the dimensionality of the projection.\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     */\nconstructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=[\"labels\"],this.parameter(\"labels\",e),this}\n/**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach(((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}}));\n// create X_mean and vector means;\nlet o=t.mean,a=new Matrix(n,r);for(let t in i){let e=Matrix.from(i[t].rows).meanCols;for(let s=0;s<r;++s)a.set_entry(i[t].id,s,e[s])}\n// scatter_between\nlet h=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t]-o)),n=i[t].count;h=h.add(s.dot(s.transpose()).mult(n))}\n// scatter_within\nlet l=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t])),n=i[t].rows;for(let e=0,o=i[t].count;e<o;++e){let t=new Matrix(r,1,((t,r)=>n[e][t]-s.entry(t,0)));l=l.add(t.dot(t.transpose()))}}let{eigenvectors:_}=simultaneous_poweriteration$1(l.inverse().dot(h),this._d);\n// return embedding\nreturn _=Matrix.from(_).transpose(),this.Y=t.dot(_),this.projection}}\n/**\n * @class\n * @alias LLE\n */class LLE extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LLE\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Number} neighbors - the label / class of each data point.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     */\nconstructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=[\"k\"],this.parameter(\"k\",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this}\n/**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */transform(){const t=this.X,e=this._d,r=this._N,s=this._D,i=this.parameter(\"k\"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(i,1,1),a=new Matrix(r,r);for(let e=0;e<r;++e){const r=n[e],h=new Matrix(i,s,((s,i)=>t.entry(r[s].j,i)-t.entry(e,i))),l=h.dot(h.T);if(i>s){const t=neumair_sum(l.diag)/1e3;for(let e=0;e<i;++e)l.set_entry(e,e,l.entry(e,e)+t)}\n// reconstruct;\nlet _=Matrix.solve_CG(l,o,this._randomizer);_=_.divide(_.sum);for(let t=0;t<i;++t)a.set_entry(e,r[t].j,_.entry(t,0))}\n// comp embedding\nconst h=new Matrix(r,r,\"identity\").sub(a),l=h.T.dot(h),{eigenvectors:_}=simultaneous_poweriteration$1(l.T.inverse(),e+1);\n// return embedding\nreturn this.Y=Matrix.from(_.slice(1,1+e)).T,this.projection}}\n/**\n * @class\n * @alias LTSA\n */class LTSA extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LTSA\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Number} neighbors - the label / class of each data point.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}\n     */\nconstructor(t,e,r=2,s=euclidean,i=1212){if(super(t,r,s,i),super.parameter_list=[\"k\"],this.parameter(\"k\",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this._D<=r)throw`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${r})!`;return this}\n/**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */transform(){const t=this.X,e=this._d,[r,s]=t.shape,i=this.parameter(\"k\"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(s,s,\"center\"),a=new Matrix(r,r,0);for(let s=0;s<r;++s){\n// 1.2 compute the d largest eigenvectors of the correlation matrix\nconst r=[s,...n[s].map((t=>t.j))];let h=Matrix.from(r.map((e=>t.row(e))));\n// center X_i\nh=h.dot(o);\n// correlation matrix\nconst l=h.dot(h.transpose()),{eigenvectors:_}=simultaneous_poweriteration$1(l,e),c=Matrix.from(_),u=c.transpose().dot(c).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)a.set_entry(r[t],r[e],a.entry(r[t],r[e])-(t===e?1:0)+u.entry(t,e))}\n// 3. Aligning global coordinates\nconst{eigenvectors:h}=simultaneous_poweriteration$1(a,e+1);\n// return embedding\nreturn this.Y=Matrix.from(h.slice(1)).transpose(),this.projection}}\n/**\n * @class\n * @alias TSNE\n */class TSNE extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias TSNE\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} [perplexity = 50] - perplexity.\n     * @param {Number} [epsilon = 10] - learning parameter.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @returns {TSNE}\n     */\nconstructor(t,e=50,r=10,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=[\"perplexity\",\"epsilon\"],[this._N,this._D]=this.X.shape,this.parameter(\"perplexity\",Math.min(e,this._N-1)),this.parameter(\"epsilon\",r),this._iter=0,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}init(t=null){\n// init\nconst e=Math.log(this._perplexity),r=this._N,s=this._D,i=this._metric,n=this.X;let o;if(t)o=t;else{o=new Matrix(r,r);for(let t=0;t<r;++t){const e=n.row(t);for(let s=t+1;s<r;++s){const r=i(e,n.row(s));o.set_entry(t,s,r),o.set_entry(s,t,r)}}}const a=new Matrix(r,r,\"zeros\");this._ystep=new Matrix(r,s,\"zeros\"),this._gains=new Matrix(r,s,1);\n// search for fitting sigma\nlet h=new Array(r).fill(0);for(let t=0;t<r;++t){let s=-1/0,i=1/0,n=1,l=!1,_=0;for(;!l;){let a=0;for(let e=0;e<r;++e){let r=Math.exp(-o.entry(t,e)*n);t===e&&(r=0),h[e]=r,a+=r}let c=0;for(let t=0;t<r;++t){let e=0===a?0:h[t]/a;h[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(s=n,n=i===1/0?2*n:(n+i)/2):(i=n,n=s===-1/0?n/2:(n+s)/2),++_,Math.abs(c-e)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let e=0;e<r;++e)a.set_entry(t,e,h[e])}\n//compute probabilities\nconst l=new Matrix(r,r,\"zeros\"),_=2*r;for(let t=0;t<r;++t)for(let e=t;e<r;++e){const r=Math.max((a.entry(t,e)+a.entry(e,t))/_,1e-100);l.set_entry(t,e,r),l.set_entry(e,t,r)}return this._P=l,this}transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init();;)this.next(),yield this.projection}\n// perform optimization\nnext(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,n=this._epsilon,o=this._d;let a=this.Y;\n//calc cost gradient;\nconst h=t<100?4:1,l=new Matrix(i,i,\"zeros\");\n// compute Q dist (unnormalized)\nlet _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<o;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}\n// normalize Q dist\nconst c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,o,\"zeros\");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<o;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}\n// perform gradient step\nlet d=new Float64Array(o);for(let e=0;e<i;++e)for(let i=0;i<o;++i){const o=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(o)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-n*_*o;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),d[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-d[e]/i);return this.Y}}\n// http://optimization-js.github.io/optimization-js/optimization.js.html#line438\nfunction powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}class UMAP extends DR{constructor(t,e=15,r=1,s=1,i=2,n=euclidean,o=1212){return super(t,i,n,o),super.parameter_list=[\"n_neighbors\",\"local_connectivity\",\"min_dist\"],[this._N,this._D]=this.X.shape,e=Math.min(this._N-1,e),this.parameter(\"n_neighbors\",e),this.parameter(\"local_connectivity\",Math.min(r,e-1)),this.parameter(\"min_dist\",s),this._iter=0,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=350,this._initial_alpha=1,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}_smooth_knn_dist(t,e){const r=1e-5,s=.001,i=this._local_connectivity,n=Math.log2(e),o=[],a=[],h=this.X,l=h.shape[0],_=[];if(\"precomputed\"===this._metric)for(let r=0;r<l;++r)_.push(t.search(r,e).reverse());else for(const r of h)_.push(t.search(r,e).raw_data().reverse());for(let t=0;t<l;++t){let h=0,l=1/0,c=1;const u=_[t],d=u.filter((t=>t.value>0)),f=d.length;if(f>=i){const e=Math.floor(i),s=i-e;e>0?(o.push(d[e-1]),s>r&&(o[t].value+=s*(d[e].value-d[e-1]))):o[t].value=s*d[0].value}else f>0&&(o[t]=d[f-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-o[t];s+=e>0?Math.exp(-e/c):1}if(Math.abs(s-n)<r)break;s>n?[l,c]=[c,(h+l)/2]:[h,c]=l===1/0?[c,2*c]:[c,(h+l)/2]}a[t]=c;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;\n//let mean_d = null;\nif(o[t]>0)a[t]<s*p&&(a[t]=s*p);else{const e=_.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));a[t]>s*e&&(a[t]=s*e)}}return{distances:_,sigmas:a,rhos:o}}_fuzzy_simplicial_set(t,e){const r=t.shape[0],s=this._metric,i=\"precomputed\"===s?new KNN(t,\"precomputed\"):new BallTree(t.to2dArray,s);let{distances:n,sigmas:o,rhos:a}=this._smooth_knn_dist(i,e);n=this._compute_membership_strengths(n,o,a);const h=new Matrix(r,r,\"zeros\");for(let t=0;t<r;++t){const e=n[t];for(let r=0;r<e.length;++r)h.set_entry(t,e[r].element.index,e[r].value)}const l=h.T,_=h.mult(l);return h.add(l).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1-this._set_op_mix_ratio))}_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this.X,this._n_neighbors);const{rows:r,cols:s,data:i}=this._tocoo(this._graph);return this._head=r,this._tail=s,this._weights=i,this._epochs_per_sample=this._make_epochs_per_sample(this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*this._negative_sample_rate)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}transform(t){this.check_init(),t=t||this._n_epochs;for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init(),this._iter=0;this._iter<this._n_epochs;)this.next(),yield this.projection;return this.projection}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(t,e,r,s){const{_d:i,_alpha:n,_repulsion_strength:o,_a:a,_b:h,_epochs_per_sample:l,_epochs_per_negative_sample:_,_epoch_of_next_negative_sample:c,_epoch_of_next_sample:u,_clip:d}=this,f=s.length;for(let p=0,m=l.length;p<m;++p)if(u[p]<=this._iter){const m=r[p],y=s[p],w=t.row(m),g=e.row(y),x=euclidean_squared(w,g);let M=0;x>0&&(M=-2*a*h*Math.pow(x,h-1)/(a*Math.pow(x,h)+1));for(let r=0;r<i;++r){const s=d(M*(w[r]-g[r]))*n,i=w[r]+s,o=g[r]-s;w[r]=i,g[r]=o,t.set_entry(m,r,i),e.set_entry(y,r,o)}u[p]+=l[p];const A=(this._iter-c[p])/_[p];for(let r=0;r<A;++r){const r=Math.floor(this._randomizer.random*f),l=e.row(s[r]),_=euclidean_squared(w,l);let c=0;if(_>0)c=2*o*h/((.01+_)*(a*Math.pow(_,h)+1));else if(m===r)continue;for(let o=0;o<i;++o){const i=d(c*(w[o]-l[o]))*n,a=w[o]+i,h=l[o]-i;w[o]=a,l[o]=h,t.set_entry(m,o,a),e.set_entry(s[r],o,h)}}c[p]+=A*_[p]}return t}next(){let t=++this._iter,e=this.Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}\n/**\n * @class\n * @alias TriMap\n */class TriMap extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias TriMap\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} [weight_adj = 500] - scaling factor.\n     * @param {Number} [c = 5] - number of triplets multiplier.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @returns {TriMap}\n     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}\n     * @see {@link https://github.com/eamid/trimap}\n     */\nconstructor(t,e=500,r=5,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=[\"weight_adj\",\"c\"],this.parameter(\"weight_adj\",e),this.parameter(\"c\",r),this}\n/**\n     * \n     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used). \n     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used). \n     */init(t=null,e=null){const r=this.X,s=r.shape[0],i=this._d,n=this._metric,o=this._c;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),//.mult(.01);\nthis.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.tol=1e-7,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}\n/**\n     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.\n     * @param {Number} n_inliers \n     * @param {Number} n_outliers \n     * @param {Number} n_random \n     */_generate_triplets(t,e,r){const s=this._metric,i=this._weight_adj,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));\n// scale parameter\nconst c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let d=this._sample_knn_triplets(u,l,t,e),f=d.shape[0];const p=new Float64Array(f);for(let t=0;t<f;++t){const e=d.entry(t,0),r=d.entry(t,2);p[t]=s(n.row(e),n.row(r))}let m=this._find_weights(d,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);d=d.concat(t,\"vertical\"),m=Float64Array.from([...m,...e])}f=d.shape[0];let y=-1/0;for(let t=0;t<f;++t)isNaN(m[t])&&(m[t]=0),y<m[t]&&(y=m[t]);let w=-1/0;for(let t=0;t<f;++t)m[t]/=y,m[t]+=1e-4,m[t]=Math.log(1+i*m[t]),w<m[t]&&(w=m[t]);for(let t=0;t<f;++t)m[t]/=w;return{triplets:d,weights:m}}\n/**\n     * Calculates the similarity matrix P\n     * @private\n     * @param {Matrix} knn_distances - matrix of pairwise knn distances\n     * @param {Float64Array} sig - scaling factor for the distances\n     * @param {Matrix} nbrs - nearest neighbors\n     * @returns {Matrix} pairwise similarity matrix\n     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}\n/**\n     * Sample nearest neighbors triplets based on the similarity values given in P.\n     * @private\n     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.\n     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.\n     * @param {Number} n_inliers - Number of inlier points.\n     * @param {Number} n_outliers - Number of outlier points.\n     * \n     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}\n/**\n     * Should do the same as np.argsort()\n     * @private\n     * @param {Array} A \n     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}\n/**\n     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.\n     * @private\n     * @param {*} n_samples \n     * @param {*} max_int \n     * @param {*} rejects \n     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}\n/**\n     * Calculates the weights for the sampled nearest neighbors triplets\n     * @private\n     * @param {Matrix} triplets - Sampled Triplets.\n     * @param {Matrix} P - Pairwise similarity matrix.\n     * @param {Matrix} nbrs - nearest Neighbors\n     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances\n     * @param {Float64Array} sig - scaling factor for the distances.\n     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}\n/**\n     * Sample uniformly ranom triplets\n     * @private\n     * @param {Matrix} X - Data matrix.\n     * @param {Number} n_random - Number of random triplets per point\n     * @param {Float64Array} sig - Scaling factor for the distances\n     */_sample_random_triplets(t,e,r){const s=this._metric,i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let d=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));d<1e-20&&(d=1e-20),u<d&&([e,c]=[c,e],[u,d]=[d,u]);const f=l+n;o.set_entry(f,0,h),o.set_entry(f,1,e),o.set_entry(f,2,c),a[f]=u/d}}return{random_triplets:o,random_weights:a}}\n/**\n     * Computes the gradient for updating the embedding.\n     * @param {Matrix} Y - The embedding\n     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Array(o).fill(0),_=new Array(o).fill(0),c=1,u=1,d=0,f=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,m]=s.row(e);\n// update y_ij, y_ik, d_ij, d_ik\nif(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(m,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}\n// update y_ik and d_ik only\n}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(m,e);_[e]=r-s,u+=_[e]**2}}c>u&&++d,f+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(m,t,h.entry(m,t)+r)}}return{grad:h,loss:f,n_viol:d}}\n/**\n     * \n     * @param {Number} max_iteration \n     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}\n/**\n     * @yields {Matrix}\n     * @returns {Matrix}\n     */*generator(){this.check_init();for(let t=0;t<800;++t)this._next(t),yield this.projection;return this.projection}\n/**\n     * Does the iteration step.\n     * @private\n     * @param {Number} iter \n     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this.tol?1.01:.9,this.Y}\n/**\n     * Updates the embedding.\n     * @private\n     * @param {Matrix} Y \n     * @param {Number} iter \n     * @param {Matrix} grad \n     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}\n/**\n * @class\n * @alias Hierarchical_Clustering\n */class Hierarchical_Clustering{\n/**\n     * @constructor\n     * @memberof module:clustering\n     * @alias Hierarchical_Clustering\n     * @todo needs restructuring. \n     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'\n     * @param {(\"single\"|\"complete\"|\"average\")} [linkage = \"complete\"] \n     * @param {Function|\"precomputed\"} [metric = euclidean] \n     * @returns {Hierarchical_Clustering}\n     */\nconstructor(t,e=\"complete\",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,\"precomputed\"===r&&t.shape[0]!==t.shape[1])throw\"If metric is 'precomputed', then matrix has to be square!\";return this.init(),this.root=this.do(),this}\n/**\n     * \n     * @param {Number} value - value where to cut the tree.\n     * @param {(\"distance\"|\"depth\")} [type = \"distance\"] - type of value.\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.\n     */get_clusters(t,e=\"distance\"){let r,s=[];switch(e){case\"distance\":r=t=>t.dist;break;case\"depth\":r=t=>t.depth;break;default:throw\"invalid type\"}return this._traverse(this.root,r,t,s),s}\n/**\n     * @private\n     * @param {} node \n     * @param {*} f \n     * @param {*} value \n     * @param {*} result \n     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}\n/**\n     * computes the tree.\n     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if(\"precomputed\"!==t){i=new Matrix(r,r,0);//new Array(n);\nfor(let n=0;n<r;++n){s[n]=0;\n//distance_matrix[i] = new Float64Array(n);\nfor(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}\n/**\n     * computes the tree.\n     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,d=c.concat(u),f=new Cluster(this._id++,l,_,r.entry(a,h),null,d);l.parent=f,_.parent=f,s[a].unshift(f),i[a]+=i[h];for(let e=0;e<t;++e)switch(n){case\"single\":r.entry(a,e)>r.entry(h,e)&&(r.set_entry(e,a,r.entry(h,e)),r.set_entry(a,e,r.entry(h,e)));break;case\"complete\":r.entry(a,e)<r.entry(h,e)&&(r.set_entry(e,a,r.entry(h,e)),r.set_entry(a,e,r.entry(h,e)));break;case\"average\":const t=(i[a]*r.entry(a,e)+i[h]*r.entry(h,e))/(i[a]+i[e]);r.set_entry(e,a,t),r.set_entry(a,e,t)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);for(let s=0;s<t;++s)e[s]===h&&(e[s]=a),r.entry(a,s)<r.entry(a,e[a])&&(e[a]=s);o=f}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}\n/**\n * @class\n * @alias KMeans\n */class KMeans{\n/**\n     * @constructor\n     * @memberof module:clustering\n     * @alias KMeans\n     * @todo needs restructuring. \n     * @param {Matrix} matrix \n     * @param {Numbers} K \n     * @param {Function} [metric = euclidean] \n     * @param {Number} [seed = 1987]\n     * @param {Boolean} [init = true]\n     * @returns {KMeans}\n     */\nconstructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}\n/**\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \n     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}\n/**\n     * @private\n     * @param {Array} points \n     * @param {Array} candidates \n     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),\"max\").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K\nfor(let e=1;e<t;++e){\n// sampling + kmeans++ improvement?\nconst t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;\n// find nearest cluster centroid.\nfor(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}\n// update cluster centroid\n// reset cluster centroids to 0\nfor(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}\n// compute centroid\nreturn this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}\n/**\n     * Computes {@link K} clusters out of the {@link matrix}.\n     * @param {Number} K - number of clusters.\n     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}\n/**\n * @class\n * @alias KMedoids\n */class KMedoids{\n/**\n     * @constructor\n     * @memberof module:clustering\n     * @alias KMedoids\n     * @todo needs restructuring. \n     * @param {Matrix} matrix - data matrix\n     * @param {Numbers} K - number of clusters\n     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)\n     * @param {Function} [metric = euclidean] - metric defining the dissimilarity \n     * @param {Number} [seed = 1212] - seed value for random number generator\n     * @returns {KMedoids}\n     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms\n     */\nconstructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,\"zeros\"),\n/* for (let i = 1; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                let dist = metric(this._A[i], this._A[j]);\n                this._distance_matrix.set_entry(i, j, dist);\n                this._distance_matrix.set_entry(j, i, dist)\n            }\n        } */\ne>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),\n//if (init) this.init(K, this._cluster_medoids);\nthis._is_initialized=!1,this}\n/**\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \n     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}\n/**\n     * Algorithm 1. FastPAM1: Improved SWAP algorithm\n     */\n/* _iteration_1() {\n        const A = this._A;\n        const N = this._N;\n        const K = this._K;\n        const medoids = this._cluster_medoids;\n        let DeltaTD = 0;\n        let m0 = null;\n        let x0 = null;\n        A.forEach((x_j, j) => {\n            if (medoids.findIndex(m => m === j) < 0) {\n                const nearest_medoid = this._nearest_medoid(x_j, j);\n                const d_j = nearest_medoid.distance_nearest; // distance to current medoid\n                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid\n                A.forEach((x_o, o) => {\n                    // disance to new medoid\n                    const d_oj = this._get_distance(o, j, x_o, x_j);\n                    const {\n                        \"index_nearest\": n,\n                        \"distance_nearest\": d_n,\n                        \"distance_second\": d_s,\n                    } = this._nearest_medoid(x_o, o); \n                    this._clusters[o] = n; // cached values\n                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change\n                    if (d_oj < d_n) { // reassignment check\n                        deltaTD.forEach((d_i, i) => {\n                            if (n !== i) {\n                                deltaTD[i] = d_i + d_oj - d_n; // update loss change\n                            }\n                        });\n                    }\n                });\n                // choose best medoid i;\n                const i = deltaTD\n                    .map((d, i) => [d, i])\n                    .sort((d1, d2) => d1[0] - d2[0])[0][1];\n                const deltaTD_i = deltaTD[i];\n                // store\n                if (deltaTD_i < DeltaTD) {\n                    DeltaTD = deltaTD_i;\n                    m0 = i;\n                    x0 = j;\n                }\n            }\n        });\n\n        if (DeltaTD >= 0) {\n            return true // break loop if DeltaTD >= 0\n        }\n        // swap roles of medoid m and non-medoid x;\n        medoids[m0] = x0;\n        this._cluster_medoids = medoids;\n        return false\n    } */\n/** Algorithm 2. FastPAM2: SWAP with multiple candidates\n     * \n     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);\n// stop if no improvements were found\nif(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid\n// change if making j a medoid\nt.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid\n// loss change for x_o\n// Reassignment check\nif(// cached\nh[n]+=Math.min(i,_)-l,i<l)\n// update loss change\nfor(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),\n// remember best swap for i;\nh.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),Math.min(...i)>=0)return!0;\n// execute all improvements\nfor(;Math.min(...i)<0;){\n// swap roles of medoid m_i and non_medoid xs_i\nconst e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),\n// disable the swap just performed\ni[e]=0,\n// recompute TD for remaining swap candidates\ni.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}\n/**\n     * Computes {@link K} clusters out of the {@link matrix}.\n     * @param {Number} K - number of clusters.\n     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}\n/**\n     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.\n     * @param {number} K - number of clusters\n     * \n     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];\n// first medoid\nlet h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum\na.push(e))}\n// other medoids\nfor(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-Math.min(...a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}\n// best reduction\ns<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}\n/**\n * @class\n * @alias OPTICS\n */class OPTICS{\n/**\n     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.\n     * @constructor\n     * @memberof module:clustering\n     * @alias OPTICS\n     * @todo needs restructuring. \n     * @param {Matrix} matrix - the data.\n     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.\n     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)\n     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.\n     * @returns {OPTICS}\n     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}\n     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}\n     */\nconstructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}\n/**\n     * Computes the clustering.\n     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),\"min\");this._update(e,t),this._expand_cluster(t,i[n])}return this}\n/**\n     * \n     * @private\n     * @param {Object} p - a point of {@link matrix}.\n     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.\n     */_get_neighbors(t){if(\"neighbors\"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}\n/**\n     * \n     * @private\n     * @param {Object} p - a point of {@link matrix}.\n     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.\n     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}\n/**\n     * Updates the reachability distance of the points.\n     * @private\n     * @param {Object} p \n     * @param {Heap} seeds \n     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;\nfor(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));\n//if (q.reachability_distance == undefined) { // q is not in seeds\ne.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds\ni<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),\"min\"))}}\n/**\n     * Expands the {@link cluster} with points in {@link seeds}.\n     * @private\n     * @param {Heap} seeds \n     * @param {Array} cluster \n     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}\n/**\n     * Returns an array of clusters.\n     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.\n     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}\n/**\n     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)\n     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}\n/**\n * @class\n * @alias LSP\n */class LSP extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LSP\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {number} [k = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.\n     * @param {number} [control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints\n     * @param {number} [d = 2] - the dimensionality of the projection.\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @returns {LSP}\n     * @see {@link https://ieeexplore.ieee.org/document/4378370}\n     */\nconstructor(t,e,r,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=[\"k\",\"control_points\"],this.parameter(\"k\",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter(\"control_points\",Math.min(r??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}\n/**\n     * \n     * @param {DR} DR - method used for position control points.\n     * @param {DR_parameters} DR_parameters - array containing parameters for the DR method which projects the control points\n     * @returns {LSP} \n     */init(t=MDS,e=[],r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter(\"k\"),o=this._d,a=this._metric,h=this.parameter(\"control_points\"),l=new KMedoids(s,h,null,a).get_clusters().medoids,_=new Matrix(h,i,\"zeros\");l.forEach(((t,e)=>{_.set_entry(e,t,1)}));const c=new t(Matrix.from(l.map((t=>s.row(t)))),...e,o).transform(),u=s.to2dArray,d=new r(u,a),f=new Matrix(i,i,\"I\"),p=-1/n;u.forEach(((t,e)=>{for(const{index:r}of d.search(t,n).iterate())e!==r&&f.set_entry(e,r,p)}));const m=f.concat(_,\"vertical\"),y=new Matrix(i,o,\"zeros\").concat(c,\"vertical\");return this._A=m,this._b=y,this._is_initialized=!0,this}\n/**\n     * Computes the projection.\n     * @returns {Matrix} Returns the projection.\n     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}class TopoMap extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias Topomap\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @returns {TopoMap}\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\n     */\nconstructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),super.parameter_list=[],[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}\n/**\n     * @private\n     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}\n/**\n     * Computes the minimum spanning tree, using a given metric\n     * @private\n     * @param {Function} metric \n     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}\n/**\n     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.\n     */init(){return this.Y=new Matrix(this._N,this._d,0),this._Emst=this._make_minimum_spanning_tree(this._metric),this._is_initialized=!0,this}\n/**\n     * Returns true if Point C is left of line AB.\n     * @private\n     * @param {Array} PointA - Point A of line AB\n     * @param {Array} PointB - Point B of line AB\n     * @param {Array} PointC - Point C\n     * @returns {Boolean}\n     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}\n/**\n     * Computes the convex hull of the set of Points S\n     * @private\n     * @param {Array} S - Set of Points.\n     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}\n     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.\n     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}\n/**\n     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.\n     * @private\n     * @param {Array} PointA \n     * @param {Array} PointB\n     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.  \n     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}\n/**\n     * @private\n     * @param {Array} hull \n     * @param {Array} p \n     * @param {Bool} topEdge\n     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}\n/**\n     * @private\n     * @param {Array} Point - The point which should get transformed.\n     * @param {Object} Transformation - contains the values for translation and rotation.\n     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}\n/**\n     * Calls {@link __transform} for each point in Set C\n     * @private\n     * @param {Array} C - Set of points.\n     * @param {Object} t - Transform object. \n     * @param {Number} yOffset - value to offset set C.\n     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}\n/**\n     * @private\n     * @param {Array} u - point u\n     * @param {Array} v - point v\n     * @param {Number} w - edge weight w\n     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}\n/**\n     * Transforms the inputdata {@link X} to dimensionality 2.\n     */transform(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}class SAMMON extends DR{\n/**\n     * \n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias SAMMON\n     * @param {Matrix} X - the high-dimensional data. \n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @returns {SAMMON}\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\n     */\nconstructor(t,e=.1,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=[\"magic\"],this.parameter(\"magic\",e),[this._N,this._D]=this.X.shape,this}\n/**\n     * initializes SAMMON. Sets all projcted points to zero, and computes a minimum spanning tree.\n     */init(t=\"random\",e=null){const r=this._N,s=this._d;if(\"random\"===t){const t=this._randomizer;this.Y=new Matrix(r,s,(()=>t.random))}else this.Y=t.transform(this.X);return this.Y,this._metric,this.distance_matrix=e||this.__distance_matrix(this.X),this}\n/**\n     * @private\n     * @param {Matrix} A\n     * @returns {Matrix} \n     */__distance_matrix(t){const e=this._metric,r=t.shape[0],s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i;o<r;++o){let r=i===o?0:e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}\n/**\n     * Transforms the inputdata {@link X} to dimenionality 2.\n     */transform(t=100){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter(\"magic\"),e=this.distance_matrix,r=this._N,s=this._d,i=this._metric;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),d=u-a,f=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*d/f,_[t]+=(d-Math.pow(o[t],2)*(1+d/a)/a)/f}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t=\"0.3.16\";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,neumair_sum,norm,powell,qr,simultaneous_poweriteration$1 as simultaneous_poweriteration,sokal_michener,t as version,yule};\n","export const TAU = Math.PI * 2;\n\nexport function scaleLinear([min, max], [from, to]) {\n    const domain_span = max - min;\n    const range_span = to - from;\n    return (value) => (value - min) / domain_span * range_span + from;\n}\n\nexport function extent(array, acc = d => d) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (const entry of array) {\n        min = Math.min(acc(entry), min);\n        max = Math.max(acc(entry), max);\n    }\n    return [min, max];\n}\n\nexport function deviation(array, acc = d => d) {\n    const N = array.length;\n    let mean = 0;\n    for (const entry of array) {\n        mean += acc(entry);\n    }\n    mean /= N;\n    let dev = 0;\n    for (const entry of array) {\n        dev += (acc(entry) - mean);\n    }\n    return [mean, dev / N];\n}\n\nexport function getStatistics({values, columns}) {\n    return function() {\n        let result = {};\n        columns.forEach((dimension, i) => {\n            result[dimension] = {};\n            const [mean, std] = deviation(values, row => row[i]);\n            result[dimension].std = std;\n            result[dimension].mean = mean;\n            const [min, max] = extent(values, row => row[i]);\n            result[dimension].min = min;\n            result[dimension].max = max;\n        })\n        return result;\n    }\n}\n\nexport async function get_fetch() {\n    let fetch;\n    try {\n        if (process && typeof process !== undefined && process.release.name === \"node\") {\n            fetch = (await import(\"cross-fetch\")).fetch;\n        }\n    } catch {\n        fetch = window.fetch;\n    }\n    return fetch;\n}\n\nexport function parse_openml_mnist_data(raw_data, fn_apply_to_value = (v) => v) {\n    const [all_columns, ...values_tmp] = raw_data.split(/\\r?\\n|\\r/).map(row => row.split(\",\"));\n    const all_labels = [];\n    const all_values = [];\n    values_tmp.forEach((row) => {\n        all_values.push(row.slice(0, -1).map(fn_apply_to_value));\n        all_labels.push(row.slice(-1)[0]);\n    });\n    return { all_columns, all_values, all_labels };\n}","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics } from \"./utils.js\";\n\n/**\n * Creates a uniform grid in 2d and adds a third dimensions by sin(x * {@link freq_x}) * cos(y * {@link freq_y}) * {@link amplitude}.\n * @param {Object} parameters \n * @param {Number} [parameters.N = 400] - Number of points.\n * @param {Float} [parameters.freq_x = 1] - Multiplicator for sin in the x-direction.\n * @param {Float} [parameters.freq_y = 1] - Multiplicator for cos in the y-direction.\n * @param {Float} [parameters.amplitude = 2] - Amplitutde for z-direction.\n * @param {Float} [parameters.noise = 0] - Add uniform noise to each point at each direction.\n * @param {Number} [parameters.seed = 4711] - Seed for the random number generator.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final waves dataset.\n */\nexport default function waves({N = 400, freq_x = 1, freq_y = 1, amplitude = 2, noise = 0, seed = 4711} = {}) {\n    const R = new Randomizer(seed);\n    const a = Math.ceil(Math.sqrt(N));\n    let values = [];\n    const labels = [];\n    const columns = [\"axis_1\", \"axis_2\", \"axis_3\"];\n    for (let i = 0; i < N; ++i) {\n        let y = i % a / a - .5;\n        let x = Math.floor(i / a) / a - .5;\n        let z = Math.sin(x * freq_x) * Math.cos(y * freq_y) * amplitude\n        values.push([x, y, z]);\n        labels.push(Math.floor(i / N * 8));\n    }\n    if (noise > 0) {\n        values = values.map((row) => {\n            return row.map(value => value + R.random * noise);\n        })\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const WAVES = waves();","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics, TAU } from \"./utils.js\";\n\n/**\n * Creates a swissroll.\n * @param {Object} parameters \n * @param {Number} parameters.N - Number of points.\n * @param {Float} parameters.alpha_start - Angle from which the swissroll starts.\n * @param {Float} parameters.alpha_end - Angle at which the swissroll ends.\n * @param {Float} parameters.noise - Add uniform noise to each point at each direction.\n * @param {Float} parameters.width - Width of the swissroll.\n * @param {Number} parameters.seed - Seed for the random number generator.\n * @param {Number} parameters.num_labels - Number of labels for the swissroll, partitions the swissroll in num_labels parts according to the angle.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final swissroll dataset.\n */\nexport default function swissroll({N = 400, alpha_start = 1, alpha_end = 2.5, noise = 0, width = 20, seed = 4711, num_labels = 8} = {}) {\n    const R = new Randomizer(seed);\n    let values = new Array(N);\n    const labels = new Array(N);\n    const columns = [\"X\", \"Y\", \"Z\"];\n    for (let i = 0; i < N; ++i) {\n        const alpha = (alpha_start + (i / N * (alpha_end - alpha_start))) * TAU;\n        const x = alpha * Math.cos(alpha);\n        const y = alpha * Math.sin(alpha);\n        const z = width * R.random - width / 2;\n        values[i] = [x, y, z];\n        labels[i] = Math.floor(i / Math.floor(N / num_labels));\n    }\n    if (noise > 0) {\n        values = values.map((row) => {\n            return row.map(value => value + R.random * noise);\n        })\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const SWISSROLL = swissroll();","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics } from \"./utils.js\";\n\n/**\n * Creates a s-shape.\n * @param {Object} parameters \n * @param {Number} parameters.N - Number of points.\n * @param {Float} parameters.noise - Add uniform noise to each point at each direction.\n * @param {Float} parameters.width - Width of the s-shape.\n * @param {Number} parameters.seed - Seed for the random number generator.\n * @param {Number} parameters.num_labels - Number of labels for the s-shape, partitions the s-shape in num_labels parts according to the angle.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final s-shape dataset.\n */\nexport default function sshape({N = 400, noise = 0, width = 20, seed = 4711, num_labels = 8} = {}) {\n    const R = new Randomizer(seed);\n    let values = new Array(N);\n    const labels = new Array(N);\n    const columns = [\"X\", \"Y\", \"Z\"];\n    for (let i = 0; i < N; ++i) {\n        const alpha = 3 * Math.PI * (i / N - .5)\n        const x = -Math.sin(alpha);\n        const y = Math.sign(alpha) * (Math.cos(alpha) - 1);\n        const z = width * R.random - width / 2;\n        values[i] = [x, y, z];\n        labels[i] = Math.floor(i / (N / num_labels));\n    }\n    if (noise > 0) {\n        values = values.map((row) => {\n            return row.map(value => value + R.random * noise);\n        })\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const SSHAPE = sshape();","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics } from \"./utils.js\";\n\n/**\n * Creates a rays dataset consisting of {@link parameters.D} rays.\n * @param {Object} parameters \n * @param {Number} [parameters.N = 400] - Roughly the number of points, uses round(N / D) * D.\n * @param {Number} [parameters.D = 7] - Number of rays, and number of the results dimensionality. Creates a ray per direction.\n * @param {Float} [parameters.noise = 0] - Add uniform noise to each point at each direction.\n * @param {Boolean} [parameters.touching = false] - Defines if the rays touches each other at the origin.\n * @param {Float} [paramter.length = 12] - Length of each ray.\n * @param {Number} [parameters.seed = 4711] - Seed for the random number generator.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final rays dataset.\n */\nexport default function rays({N = 400, D = 7, noise = 0, touching = true, length = 12, seed = 4711} = {}) {\n    const R = new Randomizer(seed);\n    const n = Math.round(N / D) * D;\n    let values = [];\n    const labels = [];\n    const columns = Array.from({length: D}, (_, i) => `axis_${i + 1}`);\n    for (let i = 0; i < n; ++i) {\n        let row = Array.from({length: D}, (_, j) => (i % D != j) ? 0 : ((i / N) * length - length / 2));\n        if (!touching) {\n            row = row.map((v, j) => v + (j - i % D))\n        }\n        values.push(row);\n        labels.push(`ray_${i % D + 1}`);\n    }\n    if (noise > 0) {\n        values = values.map((row) => {\n            return row.map(value => value + R.random * noise);\n        })\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const RAYS = rays();","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { TAU, scaleLinear, getStatistics } from \"./utils.js\";\n\n/**\n * Creates a 'moons' dataset consisting of two intersecting circles.\n * @param {Object} parameters \n * @param {Number} parameters.N - Number of points.\n * @param {Float} parameters.noise - Add uniform noise to each point at each direction.\n * @param {Float} parameters.open - How open the circles should be. Takes a value in [0 and 1), where 0 creates two full circles, 0.5 create two half circles.\n * @param {Number} parameters.seed - Seed for the random number generator.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final moons dataset.\n */\nexport default function moons({N = 400, noise = 0, open=0.5, seed = 4711} = {}) {\n    const R = new Randomizer(seed);\n    const N_alpha = Math.floor(N / 2);\n    const N_beta = N - N_alpha;\n\n    const scale = scaleLinear([0, 1], [open / 2, 1 - open / 2])\n    let values = new Array(N);\n    const labels = new Array(N);\n    const columns = [\"moon_X\", \"moon_Y\", \"moon_Z\"];\n    for (let i = 0; i < N_alpha; ++i) {\n        const alpha = TAU * scale(i / N_alpha) - TAU / 4\n        const x = Math.sin(alpha) - 0.5;\n        const y = Math.cos(alpha);\n        const z = 0\n        values[i] = [x, y, z];\n        labels[i] = \"α\";\n    }\n    for (let i = 0; i < N_beta; ++i) {\n        const alpha = TAU * scale(i / N_beta) - TAU / 4\n        const x = 1 - Math.sin(alpha) - .5;\n        const y = 0\n        const z = 1 - Math.cos(alpha) - 1; \n        values[i + N_alpha] = [x, y, z];\n        labels[i + N_alpha] = \"β\";\n    }\n    if (noise > 0) {\n        values = values.map((row) => {\n            return row.map(value => value + R.random * noise);\n        })\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const MOONS = moons();","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics } from \"./utils.js\";\n\n/**\n * Creates a dataset consisting of some gaussian blobs.\n * @param {Object} parameters \n * @param {Number} [parameters.N = 400] - Number of points.\n * @param {Number} [parameters.D = 3] - Dimensionality of the dataset.\n * @param {Array<Array>|Number} [parameters.centers = 3] - Either number of blobs, or their centers.\n * @param {Array<Array>|Number} [parameters.deviations = 1] - If a number given the deviation of the blobs in each dimension, else an array consisting the deviations for all blobs for all directions.\n * @param {Number} [parameters.seed = 4711] - Seed for the random number generator.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final blobs dataset.\n */\nexport default function blobs({N = 400, D = 3, centers, deviations, seed = 4711} = {}) {\n    const R = new Randomizer(seed);\n    const values = [];\n    const labels = [];\n    const columns = Array.from({length: D}, (_, i) => `axis_${i}`);\n\n    if (centers == null) {\n        centers = 3\n    }\n\n    if (Number.isInteger(centers)) {\n        centers = Array.from({length: centers}, () => {\n            return Array.from({length: D}, () => R.random * 12 - 6);\n        })\n    }\n\n    if (!Array.isArray(centers)) {\n        throw \"Centers needs to be an array, an integer, or null (defaults to centers = 3)!\";\n    }\n\n    if (!deviations) {\n        deviations = centers.map(center => center.map(() => 1));\n    } else {\n        if (Number.isFinite(deviations)) {\n            deviations = centers.map(center => center.map(() => deviations));\n        }\n        if (Array.isArray(deviations) && deviations.length != centers.length) {\n            throw \"If deviations is given, then its value needs to be a number or an array of the same length as centers! (defaults to deviations = 1)\";\n        }\n    }\n\n    const number_of_points_per_blob = Math.floor(N / centers.length);\n    const residuum = N - number_of_points_per_blob * centers.length;\n    const ns = Array.from({length: centers.length}, () => number_of_points_per_blob);\n    ns[0] += residuum\n    for (let i = 0; i < centers.length; ++i) {\n        const n = ns[i];\n        let randoms = [];\n        for (let d = 0; d < D; ++d) {\n            randoms.push(randomNormal(R, centers[i][d], deviations[i][d]))\n        }\n        for (let j = 0; j < n; ++j) {\n            values.push(randoms.map(r => r()));\n            labels.push(`blob_${i + 1}`);\n        }\n    }\n    \n    return {values, labels, columns, statistics: getStatistics({values, columns})};\n}\n\nexport const BLOBS = blobs();\n\n// https://github.com/d3/d3-random/blob/588790e06454c27f7dae4e7cffeadf2c783d88c3/src/normal.js\nfunction randomNormal(R, mu = 0, sigma = 1) {\n    let x;\n    let r;\n    return function() {\n        let y;\n        if (x != null) {\n            y = x;\n            x = null;\n        } else {\n            do {\n                x = R.random * 2 - 1;\n                y = R.random * 2 - 1;\n                r = x * x + y * y;\n            } while (!r || r > 1);\n        }\n        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n    }\n}","import { getStatistics } from \"./utils.js\";\nimport * as PENGUINS_RAW from \"../dataset/penguins.json\";\n\n/**\n * Returns the Palmers Penguins dataset.\n * @param {Object} parameters\n * @param {false|\"all\"|\"values\"} [removeMissingValues = \"all\"] - Remove missing values, if \"all\" then remove all rows if a null is in any column. If \"values\", then remove rows only if only the respective row in values contains a null. If false, then no missing value gets removed.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, sex: Array<String>, year: Array<Number>, island: Array<String>, statistics: Object}} - The final penguins dataset.\n */\nexport default function penguins({removeMissingValues = \"all\"} = {}) {\n    let {values, columns, labels, sex, year, island, statistics} = PENGUINS_RAW;\n    if (removeMissingValues == \"all\" || removeMissingValues == \"values\") {\n        const N = values.length;\n        let valid_indices = [];\n        let result = true;\n\n        for (let i = 0; i < N; ++i) {\n            result = true;\n            if (removeMissingValues == \"all\") {\n                if (!year[i] || !sex[i] || !labels[i] || !island[i]) {\n                    result = result && false;\n                }\n            }\n            if (removeMissingValues == \"all\" || removeMissingValues == \"values\") {\n                for (const value of values[i]) {\n                    result = result && !Number.isNaN(value);\n                }\n            }   \n            if (result == true) valid_indices.push(i);\n        }\n\n        values = filter(values, valid_indices);\n        labels = filter(labels, valid_indices);\n        sex = filter(sex, valid_indices);\n        year = filter(year, valid_indices);\n        island = filter(island, valid_indices);\n    }\n    // rollup removes columns from this function call\n    // const statistics = getStatistics(values, PENGUINS_RAW.columns);\n    return {values, columns, labels, sex, year, island, statistics: getStatistics(values, columns)};\n}\n\nfunction filter(values, indices) {\n    return indices.map(i => values[i]);\n}\n\nexport const PENGUINS = penguins();","import { get_fetch } from \"./utils.js\";\nconst openml_main_api = \"https://www.openml.org/api/v1/json/\";\nconst openml_file_api = \"https://www.openml.org/data/v1/get_csv/\";\n\n// MNIST = 554\n// FMNIST = 40996\n// KNNIST = 41982\n\n/**\n * Fetches data from openml.org\n * @param {Number} id - Data ID from openml.org\n * @param {String} api_key - Your api-key\n * @returns {Object} - Raw data as string, and the dataset description provided by openml.org.\n */\nexport default async function fetch_openml(id, api_key) {\n    let fetch = await get_fetch();\n\n    let url = encodeURI(`${openml_main_api}data/${id}`);\n    if (api_key) {\n        url += `?api_key=${api_key}`;\n    }\n    // Fetching for file id.\n    const main_response = await fetch(url);\n    \n    if (!main_response.ok) {\n        throw Error(`${main_response.status} ${main_response.statusText}`);\n    }\n    const description = await main_response.json();\n\n    // fetching the file.\n    const file_response = await fetch(openml_file_api + description.data_set_description.file_id);\n    if (!file_response.ok) {\n        throw Error(`${file_response.status} ${file_response.statusText}`);\n    }\n    const raw_data = await file_response.text();\n\n\n    return { raw_data, description: {} };\n}","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics, parse_openml_mnist_data } from \"./utils.js\";\nimport { default as fetch_openml } from \"./openml.js\";\n\nconst FMNIST_LABELS_DICT = {\n    0: \"T-shirt/top\",\n    1: \"Trouser\",\n    2: \"Pullover\",\n    3: \"Dress\",\n    4: \"Coat\",\n    5: \"Sandal\",\n    6: \"Shirt\",\n    7: \"Sneaker\",\n    8: \"Bag\",\n    9: \"Ankle boot\"\n}\n\n/**\n * Downloads and samples the FMNIST dataset.\n * @param {Object} parameters\n * @param {Number} [N = 400] - Number of points.\n * @param {Number} [seed = 4711] - Seed for the random number generator.\n * @param {Array<Number>} [items = [0,1,2,3,4,5,6,7,8,9]] - Filter for which items end up in the final dataset.\n * @param {String} [api_key = null] - API key for OpenML.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final FMNIST dataset sample.\n */\nexport default async function({N = 400, seed = 4711, items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], api_key} = {}) {\n    const R = new Randomizer(seed);\n    const { raw_data, description } = await fetch_openml(40996, api_key);\n    const { all_values, all_labels } = parse_openml_mnist_data(raw_data, value => +value / 255);\n\n    const n = Math.floor(N / items.length);\n    const number_digits = Array.from({length: items.length}, () => n)\n    number_digits[0] += (N - (n * items.length));\n    \n    const indices = all_labels.map((_, i) => i);\n    const filtered_indices = items.map(digit => indices.filter(i => all_labels[i] == digit));\n    const selected_indices = number_digits.map((n, i) => R.choice(filtered_indices[i], n)).flat();\n    const values = [];\n    const labels = []\n    for (const i of selected_indices) {\n        values.push(all_values[i]);\n        labels.push(FMNIST_LABELS_DICT[all_labels[i]]);\n    }\n    const columns = Array.from({length: 28 * 28}, (_, i) => `pixel_at_${i % 28}_${Math.floor(i / 28)}`);\n    return {values, labels, columns, statistics: getStatistics({values, columns}), description};\n}\n","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics, parse_openml_mnist_data } from \"./utils.js\";\nimport { default as fetch_openml } from \"./openml.js\";\n\nconst KMNIST_LABELS_DICT = {\n    0: \"お\",\n    1: \"き\",\n    2: \"す\",\n    3: \"つ\",\n    4: \"な\",\n    5: \"は\",\n    6: \"ま\",\n    7: \"や\",\n    8: \"れ\",\n    9: \"を\"\n}\n\n/**\n * Downloads and samples the Kuzushiji-MNIST dataset.\n * @param {Object} parameters\n * @param {Number} [N = 400] - Number of points.\n * @param {Number} [seed = 4711] - Seed for the random number generator.\n * @param {Array<Number>} [items = [0,1,2,3,4,5,6,7,8,9]] - Filter for which items end up in the final dataset.\n * @param {String} [api_key = null] - API key for OpenML.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final Kuzushiji-MNIST dataset sample.\n * @see{@link{https://arxiv.org/abs/1812.01718}}\n */\nexport default async function({N = 400, seed = 4711, letters = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], api_key} = {}) {\n    const R = new Randomizer(seed);\n    const { raw_data, description } = await fetch_openml(41982, api_key);\n    const { all_values, all_labels } = parse_openml_mnist_data(raw_data, value => +value / 255);\n\n    const n = Math.floor(N / letters.length);\n    const number_digits = Array.from({length: letters.length}, () => n)\n    number_digits[0] += (N - (n * letters.length));\n    \n    const indices = all_labels.map((_, i) => i);\n    const filtered_indices = letters.map(digit => indices.filter(i => all_labels[i] == digit));\n    const selected_indices = number_digits.map((n, i) => R.choice(filtered_indices[i], n)).flat();\n    const values = [];\n    const labels = []\n    for (const i of selected_indices) {\n        values.push(all_values[i]);\n        labels.push(KMNIST_LABELS_DICT[all_labels[i]]);\n    }\n    const columns = Array.from({length: 28 * 28}, (_, i) => `pixel_at_${i % 28}_${Math.floor(i / 28)}`);\n    return {values, labels, columns, statistics: getStatistics({values, columns}), description};\n}\n","import { Randomizer } from \"@saehrimnir/druidjs\";\nimport { getStatistics, parse_openml_mnist_data } from \"./utils.js\";\nimport { default as fetch_openml } from \"./openml.js\";\n\n/**\n * Downloads and samples the MNIST dataset.\n * @param {Object} parameters\n * @param {Number} [N = 400] - Number of points.\n * @param {Number} [seed = 4711] - Seed for the random number generator.\n * @param {Array<Number>} [digits = [0,1,2,3,4,5,6,7,8,9]] - Filter for which digits end up in the final dataset.\n * @param {String} [api_key = null] - API key for OpenML.\n * @returns {{values: Array<Array>, labels: Array<String>, columns: Array<String>, statistics: Object}} - The final MNIST dataset sample.\n */\nexport default async function({N = 400, seed = 4711, digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], api_key} = {}) {\n    const R = new Randomizer(seed);\n    const { raw_data, description } = await fetch_openml(554, api_key);\n    const { all_values, all_labels } = parse_openml_mnist_data(raw_data, value => +value / 255);\n\n    const n = Math.floor(N / digits.length);\n    const number_digits = Array.from({length: digits.length}, () => n)\n    number_digits[0] += (N - (n * digits.length));\n    \n    const indices = all_labels.map((_, i) => i);\n    const filtered_indices = digits.map(digit => indices.filter(i => all_labels[i] == digit));\n    const selected_indices = number_digits.map((n, i) => R.choice(filtered_indices[i], n)).flat();\n    const values = [];\n    const labels = [];\n    for (const i of selected_indices) {\n        values.push(all_values[i]);\n        labels.push(all_labels[i]);\n    }\n    const columns = Array.from({length: 28 * 28}, (_, i) => `pixel_at_${i % 28}_${Math.floor(i / 28)}`);\n    return { values, labels, columns, statistics: getStatistics({values, columns}), description };\n}"],"names":["neumair_sum","t","e","length","r","s","i","n","Math","abs","Matrix","constructor","this","_rows","_cols","_data","Float64Array","static","clone","Array","isArray","row","subarray","iterate_rows","Symbol","iterator","set_row","shape","col","entry","set_entry","transpose","T","inverse","o","dot","join","a","map","outer","concat","set_block","get_block","gather","_apply_array","_apply_rowwise_array","_apply_colwise_array","_apply","slice","mult","divide","add","sub","to2dArray","diag","min","mean","sum","meanRows","from","meanCols","h","random","l","_","L","U","LU","eigenvectors","eigenvalues","simultaneous_poweriteration","Sigma","sqrt","V","linspace","max","round","Randomizer","_N","_M","_MATRIX_A","_UPPER_MASK","_LOWER_MASK","_mt","_mti","N","seed","Date","getTime","_seed","random_int","choice","splice","TAU","PI","getStatistics","values","columns","result","forEach","dimension","std","array","acc","d","dev","deviation","Infinity","extent","parse_openml_mnist_data","raw_data","fn_apply_to_value","v","all_columns","values_tmp","split","all_labels","all_values","push","waves","freq_x","freq_y","amplitude","noise","R","ceil","labels","y","x","floor","z","sin","cos","value","statistics","WAVES","swissroll","alpha_start","alpha_end","width","num_labels","alpha","SWISSROLL","sshape","sign","SSHAPE","rays","D","touching","j","RAYS","moons","open","N_alpha","N_beta","scale","to","domain_span","range_span","scaleLinear","MOONS","blobs","centers","deviations","Number","isInteger","isFinite","center","number_of_points_per_blob","residuum","ns","randoms","randomNormal","BLOBS","mu","sigma","log","penguins","removeMissingValues","sex","year","island","PENGUINS_RAW","valid_indices","isNaN","filter","indices","PENGUINS","async","fetch_openml","id","api_key","fetch","process","undefined","release","name","import","window","get_fetch","url","encodeURI","main_response","ok","Error","status","statusText","description","json","file_response","data_set_description","file_id","text","FMNIST_LABELS_DICT","KMNIST_LABELS_DICT","items","number_digits","filtered_indices","digit","selected_indices","flat","letters","digits"],"mappings":"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"}